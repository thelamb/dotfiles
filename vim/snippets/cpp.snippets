snippet inc 
	#include <${1}>${2}
snippet ino 
	#include "${1}.h"${2}
snippet map
	std::map<${1:key}, ${2:value}> ${3};
snippet umap
	std::unordered_map<${1:key}, ${2:value}> ${3};
snippet vector
	std::vector<${1:char}> ${2};
snippet remove_if
	${1:container}.erase( std::remove_if( $1.begin(), $1.end(), [${2}]( const ${3:type}& aVal ) 
		{
			${4}	
		} ), $1.end() );
		${5}

snippet InitAndDestruct
	struct InitAndDestruct_${1} : public commons::InitAndDestruct 
	{
		void initConfig() override
		{

		}

		void init() override
		{

		}

		void destruct() override
		{

		}

		std::string identity() override { return "${2}$1"; }
	};

	InitAndDestruct_$1 gInitAndDestruct_$1;
snippet ui_SCPHandler
	struct SCPHandler_${1} : public ui::SCPCallback
	{
		void onSCPCommand( scp::enCommandCode aCommand, const ui::scp_cmd_type* aRequestP,
						   std::unique_ptr<ui::scp_cmd_type>& aResponsePtr ) override
		{
			switch( aCommand )
			{
			case scp::enCommandCode::${3}:
			{

			}
			}
		}

		void onSCPCommandCompleted( scp::enCommandCode aCommandCode, const ui::scp_cmd_type*, scp::enCommandCode,
									const ui::scp_cmd_type* ) override
		{
		}

		std::string identity() override { return "${2}"; }
	};
snippet ui_TerminalCallback
	struct TerminalCallback_${1} : public ui::TerminalCallback
	{
		void onTerminalCommand( const std::string& aCategory, const std::string& aCommand,
								std::map<std::string, ui::terminal::ParamValue>& aValues ) override
		{
		}

		std::string identity() override { return "${2}$1"; }
	};
snippet class
	class ${1:class} 
	{
		${2}

	public:
		$1( ) = default;
	};

snippet struct
	struct ${1:class} 
	{
		${2}

	public:
		$1( ) = default;
	};

snippet lock
	// BEGIN SCOPED LOCK
	auto lock = ${1:mLock}.getScopedLock();
	${2}
	// END SCOPED LOCK
snippet ns
	namespace ${1:ns} {
		${2}
	} // namespace $1 
snippet ns2
	namespace ${1:ns} {
	namespace ${2:ns} {
		${3}
	} // namespace $2 
	} // namespace $1 
snippet ns3
	namespace ${1:ns} {
	namespace ${2:ns} {
	namespace ${3:ns} {
		${4}
	} // namespace $3 
	} // namespace $2 
	} // namespace $1 
snippet ns4
	namespace ${1:ns} {
	namespace ${2:ns} {
	namespace ${3:ns} {
	namespace ${4:ns} {
		${5}
	} // namespace $4 
	} // namespace $3 
	} // namespace $2 
	} // namespace $1 
snippet for 
	for( auto& ${1} : ${2} )
	{
		${3}
	}
snippet fori
	auto itEnd = ${1:container}.end();
	for( auto it = $1.begin(); it != itEnd; ++it ) 
	{
		${4}
	}
snippet fori2
	auto itEnd${2:name} = ${1:container}.end();
	for( auto it$2 = $1.begin(); it$2 != itEnd; ++it$2 ) 
	{
		${4}
	}
snippet guard
	#ifndef ${1:filename}_H_INCLUDED
	#define $1_H_INCLUDED
	
	${2}
	
	#endif // include guard

snippet l3
	scp::enL3Proto${1}
snippet l4
	scp::enL4Proto${1}
snippet l7
	scp::enL7Proto${1}
snippet evt
	commons::evtid::${1}
snippet bc
	BOOST_CHECK( ${1} == ${2} );
snippet bce
	BOOST_CHECK_EQUAL( ${1}, ${2} );
snippet btc 
	BOOST_AUTO_TEST_CASE( ${1} )
	{
		ut::DefaultTestInstance testInstance;

		ut::PcapSniffer<Stream> sniff;
		
		${2}
	}
snippet bts 
	BOOST_AUTO_TEST_SUITE( ${1} )
	${2}
	BOOST_AUTO_TEST_SUITE_END() // $1
snippet printalerts
	for( auto& a : sl::nids::alert::Manager::getCCQueueRef() )
		std::cout << a->eventTypeID << "\n";
